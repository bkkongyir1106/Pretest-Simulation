source("~/Desktop/OSU/Research/Pretest-Simulation/functions/User_defined_functions.R")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/utility.R")
# set up cores for parallel processing
par_set <- function(cores_reserve = 2)
{
cores = parallel::detectCores()
cores_use <- cores - cores_reserve
if(Sys.info()["sysname"] == "Windows"){
# make a socket for both Windows & Unix-like
cl <- parallel::makeCluster(cores_use)
doParallel::registerDoParallel(cl)
}else{
# make a socket cluster for Unix-like
cl <- snow::makeSOCKcluster(cores_use)
doSNOW::registerDoSNOW(cl)
}
foreach::getDoParWorkers()
return(cl)
}
# Function to close the cluster
close_cluster <- function(cl) {
parallel::stopCluster(cl)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PERFORM SIMULATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%----
## Set up the simulation parameters
{
N <- 1e2; B <- 1e2;  alpha <- 0.05
dist_sum <- c("Standard Normal", "Uniform", "t" , "Contaminated", "Laplace","Exponential") #, "Chi-Square", "Gamma", "Weibull", "LogNormal", "Pareto")
nvec <- c(8, 10, 15, 20, 25, 30, 50)
sig_level <- c(0.05)
}
# Function to calculate the test statistic (difference of means)
calculate_test_statistic <- function(x, y) {
return((mean(x) - mean(y))/sqrt(var(x)/length(x) + var(y)/length(y)))
}
# Function to compute the area under the curve using the trapezoidal rule
compute_area <- function(x, y) {
(sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2))/(max(nvec) - min(nvec))
}
# Progress taskbar setup
{
my_cl <- par_set(cores_reserve = 2)
ntasks <- length(nvec) *  length(sig_level) * length(dist_sum)
pb <- txtProgressBar(max=ntasks, style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
}
## Perform simulation
system.time({
sim_out <- foreach(n = nvec,
.packages = c("LaplacesDemon", "VGAM"),
.options.snow=opts) %:%
foreach(dist = dist_sum) %:%
foreach(alpha = sig_level) %dopar%
{
set.seed(12345) # Set seed for reproducibility
pval_t <- pval_wilcox <- pvals <- pval_perm <- numeric(N)
time_t <- time_wilcox <- time_t_wilcox <- time_perm <- numeric(N)
for (i in 1:N) {
x <- generate_data(n, dist)
y <- generate_data(n, dist)
# perform t test
time_t[i] <- system.time(
{
pval_t[i] <- t.test(x, y)$p.value
})["elapsed"]
# Wilcoxon test
time_wilcox[i] <- system.time(
{
pval_wilcox[i] <- wilcox.test(x, y)$p.value
})["elapsed"]
# MPerform t-test/Wilcoxon
time_t_wilcox[i] <- system.time({
if (shapiro.test(x)$p.value > alpha & shapiro.test(y)$p.value > alpha) {
pvals[i] <- t.test(x, y )$p.value
} else {
pvals[i] <- wilcox.test(x, y)$p.value
}
})["elapsed"]
data <- c(x, y)
observe_stat <- calculate_test_statistic(x, y)
# Perform permutation test
time_perm[i] <- system.time({
permuted_stat <- numeric(B)
for (j in 1:B) {
sample_data <- sample(data)
sample_x <- sample_data[1:length(x)]
sample_y <- sample_data[(length(x) + 1):(length(x) + length(y))]
permuted_stat[j] <- calculate_test_statistic(sample_x, sample_y)
}
pval_perm[i] <- mean(abs(permuted_stat) >= abs(observe_stat))
})["elapsed"]
}
# Calculate Type I error rates
error_t <- mean(pval_t < alpha)
error_wilcox <- mean(pval_wilcox < alpha)
error_t_wilcox <- mean(pvals < alpha)
error_perm <- mean(pval_perm < alpha)
# Calculate average computation times
avg_time_t_list <- mean(time_t)
avg_time_wilcox_list <- mean(time_wilcox)
avg_time_t_wilcox_list <- mean(time_t_wilcox)
avg_time_perm_list <- mean(time_perm)
results <- list(error_t = error_t,
error_wilcox = error_wilcox,
error_t_wilcox = error_t_wilcox,
error_perm = error_perm)
}
close_cluster(my_cl)
## Output
errorvec <- numeric(length(nvec) * length(dist_sum))
TypeI.errorRate_t <- TypeI.errorRate_wilcox <- TypeI.errorRate_t_wilcox <- TypeI.errorRate_perm<- array(errorvec, dim = c(length(nvec), length(dist_sum)), dimnames = list(nvec, dist_sum))
for (t in seq_along(nvec)) {
for (j in seq_along(dist_sum)) {
TypeI.errorRate_t[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t)
TypeI.errorRate_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_wilcox)
TypeI.errorRate_t_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t_wilcox)
TypeI.errorRate_perm[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_perm)
}
}
})
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% UTILS %%%%%%%%%%%%%%%%%%%%%%%%%-----
# clear working environment
rm(list = ls())
# Un-comment this before submitting code to cluster
# source("/home/kongyir/spring2024/User_defined_functions.R")
# source("/home/kongyir/spring2024/utility.R")
# set directories in local computer
setwd("/Users/benedictkongyir/Desktop/OSU/Research/Pretest-Simulation/COMBINE RESULTS_20240719/TYPE I ERROR RATES")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/User_defined_functions.R")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/utility.R")
# set up cores for parallel processing
par_set <- function(cores_reserve = 2)
{
cores = parallel::detectCores()
cores_use <- cores - cores_reserve
if(Sys.info()["sysname"] == "Windows"){
# make a socket for both Windows & Unix-like
cl <- parallel::makeCluster(cores_use)
doParallel::registerDoParallel(cl)
}else{
# make a socket cluster for Unix-like
cl <- snow::makeSOCKcluster(cores_use)
doSNOW::registerDoSNOW(cl)
}
foreach::getDoParWorkers()
return(cl)
}
# Function to close the cluster
close_cluster <- function(cl) {
parallel::stopCluster(cl)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PERFORM SIMULATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%----
## Set up the simulation parameters
{
N <- 1e2; B <- 1e2;  alpha <- 0.05
dist_sum <- c("Standard Normal", "Uniform", "t" , "Contaminated", "Laplace","Exponential") #, "Chi-Square", "Gamma", "Weibull", "LogNormal", "Pareto")
nvec <- c(8, 10, 15, 20) #, 25, 30, 50)
sig_level <- c(0.05)
}
# Function to calculate the test statistic (difference of means)
calculate_test_statistic <- function(x, y) {
return((mean(x) - mean(y))/sqrt(var(x)/length(x) + var(y)/length(y)))
}
# Function to compute the area under the curve using the trapezoidal rule
compute_area <- function(x, y) {
(sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2))/(max(nvec) - min(nvec))
}
# Progress taskbar setup
{
my_cl <- par_set(cores_reserve = 2)
ntasks <- length(nvec) *  length(sig_level) * length(dist_sum)
pb <- txtProgressBar(max=ntasks, style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
}
## Perform simulation
system.time({
sim_out <- foreach(n = nvec,
.packages = c("LaplacesDemon", "VGAM"),
.options.snow=opts) %:%
foreach(dist = dist_sum) %:%
foreach(alpha = sig_level) %dopar%
{
set.seed(12345) # Set seed for reproducibility
pval_t <- pval_wilcox <- pvals <- pval_perm <- numeric(N)
time_t <- time_wilcox <- time_t_wilcox <- time_perm <- numeric(N)
for (i in 1:N) {
x <- generate_data(n, dist)
y <- generate_data(n, dist)
# perform t test
time_t[i] <- system.time(
{
pval_t[i] <- t.test(x, y)$p.value
})["elapsed"]
# Wilcoxon test
time_wilcox[i] <- system.time(
{
pval_wilcox[i] <- wilcox.test(x, y)$p.value
})["elapsed"]
# MPerform t-test/Wilcoxon
time_t_wilcox[i] <- system.time({
if (shapiro.test(x)$p.value > alpha & shapiro.test(y)$p.value > alpha) {
pvals[i] <- t.test(x, y )$p.value
} else {
pvals[i] <- wilcox.test(x, y)$p.value
}
})["elapsed"]
data <- c(x, y)
observe_stat <- calculate_test_statistic(x, y)
# Perform permutation test
time_perm[i] <- system.time({
permuted_stat <- numeric(B)
for (j in 1:B) {
sample_data <- sample(data)
sample_x <- sample_data[1:length(x)]
sample_y <- sample_data[(length(x) + 1):(length(x) + length(y))]
permuted_stat[j] <- calculate_test_statistic(sample_x, sample_y)
}
pval_perm[i] <- mean(abs(permuted_stat) >= abs(observe_stat))
})["elapsed"]
}
# Calculate Type I error rates
error_t <- mean(pval_t < alpha)
error_wilcox <- mean(pval_wilcox < alpha)
error_t_wilcox <- mean(pvals < alpha)
error_perm <- mean(pval_perm < alpha)
# Calculate average computation times
avg_time_t_list <- mean(time_t)
avg_time_wilcox_list <- mean(time_wilcox)
avg_time_t_wilcox_list <- mean(time_t_wilcox)
avg_time_perm_list <- mean(time_perm)
results <- list(error_t = error_t,
error_wilcox = error_wilcox,
error_t_wilcox = error_t_wilcox,
error_perm = error_perm)
}
close_cluster(my_cl)
## Output
errorvec <- numeric(length(nvec) * length(dist_sum))
TypeI.errorRate_t <- TypeI.errorRate_wilcox <- TypeI.errorRate_t_wilcox <- TypeI.errorRate_perm<- array(errorvec, dim = c(length(nvec), length(dist_sum)), dimnames = list(nvec, dist_sum))
for (t in seq_along(nvec)) {
for (j in seq_along(dist_sum)) {
TypeI.errorRate_t[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t)
TypeI.errorRate_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_wilcox)
TypeI.errorRate_t_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t_wilcox)
TypeI.errorRate_perm[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_perm)
}
}
})
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% UTILS %%%%%%%%%%%%%%%%%%%%%%%%%-----
# clear working environment
rm(list = ls())
# Un-comment this before submitting code to cluster
# source("/home/kongyir/spring2024/User_defined_functions.R")
# source("/home/kongyir/spring2024/utility.R")
# set directories in local computer
setwd("/Users/benedictkongyir/Desktop/OSU/Research/Pretest-Simulation/COMBINE RESULTS_20240719/TYPE I ERROR RATES")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/User_defined_functions.R")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/utility.R")
# set up cores for parallel processing
par_set <- function(cores_reserve = 2)
{
cores = parallel::detectCores()
cores_use <- cores - cores_reserve
if(Sys.info()["sysname"] == "Windows"){
# make a socket for both Windows & Unix-like
cl <- parallel::makeCluster(cores_use)
doParallel::registerDoParallel(cl)
}else{
# make a socket cluster for Unix-like
cl <- snow::makeSOCKcluster(cores_use)
doSNOW::registerDoSNOW(cl)
}
foreach::getDoParWorkers()
return(cl)
}
# Function to close the cluster
close_cluster <- function(cl) {
parallel::stopCluster(cl)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PERFORM SIMULATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%----
## Set up the simulation parameters
{
N <- 1e1; B <- 1e1;  alpha <- 0.05
dist_sum <- c("Standard Normal", "Uniform", "t" , "Contaminated", "Laplace","Exponential") #, "Chi-Square", "Gamma", "Weibull", "LogNormal", "Pareto")
nvec <- c(8, 10, 15, 20) #, 25, 30, 50)
sig_level <- c(0.05)
}
# Function to calculate the test statistic (difference of means)
calculate_test_statistic <- function(x, y) {
return((mean(x) - mean(y))/sqrt(var(x)/length(x) + var(y)/length(y)))
}
# Function to compute the area under the curve using the trapezoidal rule
compute_area <- function(x, y) {
(sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2))/(max(nvec) - min(nvec))
}
# Progress taskbar setup
{
my_cl <- par_set(cores_reserve = 2)
ntasks <- length(nvec) *  length(sig_level) * length(dist_sum)
pb <- txtProgressBar(max=ntasks, style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
}
## Perform simulation
system.time({
sim_out <- foreach(n = nvec,
.packages = c("LaplacesDemon", "VGAM"),
.options.snow=opts) %:%
foreach(dist = dist_sum) %:%
foreach(alpha = sig_level) %dopar%
{
set.seed(12345) # Set seed for reproducibility
pval_t <- pval_wilcox <- pvals <- pval_perm <- numeric(N)
time_t <- time_wilcox <- time_t_wilcox <- time_perm <- numeric(N)
for (i in 1:N) {
x <- generate_data(n, dist)
y <- generate_data(n, dist)
# perform t test
time_t[i] <- system.time(
{
pval_t[i] <- t.test(x, y)$p.value
})["elapsed"]
# Wilcoxon test
time_wilcox[i] <- system.time(
{
pval_wilcox[i] <- wilcox.test(x, y)$p.value
})["elapsed"]
# MPerform t-test/Wilcoxon
time_t_wilcox[i] <- system.time({
if (shapiro.test(x)$p.value > alpha & shapiro.test(y)$p.value > alpha) {
pvals[i] <- t.test(x, y )$p.value
} else {
pvals[i] <- wilcox.test(x, y)$p.value
}
})["elapsed"]
data <- c(x, y)
observe_stat <- calculate_test_statistic(x, y)
# Perform permutation test
time_perm[i] <- system.time({
permuted_stat <- numeric(B)
for (j in 1:B) {
sample_data <- sample(data)
sample_x <- sample_data[1:length(x)]
sample_y <- sample_data[(length(x) + 1):(length(x) + length(y))]
permuted_stat[j] <- calculate_test_statistic(sample_x, sample_y)
}
pval_perm[i] <- mean(abs(permuted_stat) >= abs(observe_stat))
})["elapsed"]
}
# Calculate Type I error rates
error_t <- mean(pval_t < alpha)
error_wilcox <- mean(pval_wilcox < alpha)
error_t_wilcox <- mean(pvals < alpha)
error_perm <- mean(pval_perm < alpha)
# Calculate average computation times
avg_time_t_list <- mean(time_t)
avg_time_wilcox_list <- mean(time_wilcox)
avg_time_t_wilcox_list <- mean(time_t_wilcox)
avg_time_perm_list <- mean(time_perm)
results <- list(error_t = error_t,
error_wilcox = error_wilcox,
error_t_wilcox = error_t_wilcox,
error_perm = error_perm)
}
close_cluster(my_cl)
## Output
errorvec <- numeric(length(nvec) * length(dist_sum))
TypeI.errorRate_t <- TypeI.errorRate_wilcox <- TypeI.errorRate_t_wilcox <- TypeI.errorRate_perm<- array(errorvec, dim = c(length(nvec), length(dist_sum)), dimnames = list(nvec, dist_sum))
for (t in seq_along(nvec)) {
for (j in seq_along(dist_sum)) {
for(k in seq_along(seg_level)){
TypeI.errorRate_t[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t)
TypeI.errorRate_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_wilcox)
TypeI.errorRate_t_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t_wilcox)
TypeI.errorRate_perm[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_perm)
}
}
}
})
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% UTILS %%%%%%%%%%%%%%%%%%%%%%%%%-----
# clear working environment
rm(list = ls())
# Un-comment this before submitting code to cluster
# source("/home/kongyir/spring2024/User_defined_functions.R")
# source("/home/kongyir/spring2024/utility.R")
# set directories in local computer
setwd("/Users/benedictkongyir/Desktop/OSU/Research/Pretest-Simulation/COMBINE RESULTS_20240719/TYPE I ERROR RATES")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/User_defined_functions.R")
source("~/Desktop/OSU/Research/Pretest-Simulation/functions/utility.R")
# set up cores for parallel processing
par_set <- function(cores_reserve = 2)
{
cores = parallel::detectCores()
cores_use <- cores - cores_reserve
if(Sys.info()["sysname"] == "Windows"){
# make a socket for both Windows & Unix-like
cl <- parallel::makeCluster(cores_use)
doParallel::registerDoParallel(cl)
}else{
# make a socket cluster for Unix-like
cl <- snow::makeSOCKcluster(cores_use)
doSNOW::registerDoSNOW(cl)
}
foreach::getDoParWorkers()
return(cl)
}
# Function to close the cluster
close_cluster <- function(cl) {
parallel::stopCluster(cl)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PERFORM SIMULATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%----
## Set up the simulation parameters
{
N <- 1e1; B <- 1e1;  alpha <- 0.05
dist_sum <- c("Standard Normal", "Uniform", "t" , "Contaminated", "Laplace","Exponential") #, "Chi-Square", "Gamma", "Weibull", "LogNormal", "Pareto")
nvec <- c(8, 10, 15, 20) #, 25, 30, 50)
sig_level <- c(0.05)
}
# Function to calculate the test statistic (difference of means)
calculate_test_statistic <- function(x, y) {
return((mean(x) - mean(y))/sqrt(var(x)/length(x) + var(y)/length(y)))
}
# Function to compute the area under the curve using the trapezoidal rule
compute_area <- function(x, y) {
(sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2))/(max(nvec) - min(nvec))
}
# Progress taskbar setup
{
my_cl <- par_set(cores_reserve = 2)
ntasks <- length(nvec) *  length(sig_level) * length(dist_sum)
pb <- txtProgressBar(max=ntasks, style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
}
## Perform simulation
system.time({
sim_out <- foreach(n = nvec,
.packages = c("LaplacesDemon", "VGAM"),
.options.snow=opts) %:%
foreach(dist = dist_sum) %:%
foreach(alpha = sig_level) %dopar%
{
set.seed(12345) # Set seed for reproducibility
pval_t <- pval_wilcox <- pvals <- pval_perm <- numeric(N)
time_t <- time_wilcox <- time_t_wilcox <- time_perm <- numeric(N)
for (i in 1:N) {
x <- generate_data(n, dist)
y <- generate_data(n, dist)
# perform t test
time_t[i] <- system.time(
{
pval_t[i] <- t.test(x, y)$p.value
})["elapsed"]
# Wilcoxon test
time_wilcox[i] <- system.time(
{
pval_wilcox[i] <- wilcox.test(x, y)$p.value
})["elapsed"]
# MPerform t-test/Wilcoxon
time_t_wilcox[i] <- system.time({
if (shapiro.test(x)$p.value > alpha & shapiro.test(y)$p.value > alpha) {
pvals[i] <- t.test(x, y )$p.value
} else {
pvals[i] <- wilcox.test(x, y)$p.value
}
})["elapsed"]
data <- c(x, y)
observe_stat <- calculate_test_statistic(x, y)
# Perform permutation test
time_perm[i] <- system.time({
permuted_stat <- numeric(B)
for (j in 1:B) {
sample_data <- sample(data)
sample_x <- sample_data[1:length(x)]
sample_y <- sample_data[(length(x) + 1):(length(x) + length(y))]
permuted_stat[j] <- calculate_test_statistic(sample_x, sample_y)
}
pval_perm[i] <- mean(abs(permuted_stat) >= abs(observe_stat))
})["elapsed"]
}
# Calculate Type I error rates
error_t <- mean(pval_t < alpha)
error_wilcox <- mean(pval_wilcox < alpha)
error_t_wilcox <- mean(pvals < alpha)
error_perm <- mean(pval_perm < alpha)
# Calculate average computation times
avg_time_t_list <- mean(time_t)
avg_time_wilcox_list <- mean(time_wilcox)
avg_time_t_wilcox_list <- mean(time_t_wilcox)
avg_time_perm_list <- mean(time_perm)
results <- list(error_t = error_t,
error_wilcox = error_wilcox,
error_t_wilcox = error_t_wilcox,
error_perm = error_perm)
}
close_cluster(my_cl)
## Output
errorvec <- numeric(length(nvec) * length(dist_sum))
TypeI.errorRate_t <- TypeI.errorRate_wilcox <- TypeI.errorRate_t_wilcox <- TypeI.errorRate_perm<- array(errorvec, dim = c(length(nvec), length(dist_sum)), dimnames = list(nvec, dist_sum))
for (t in seq_along(nvec)) {
for (j in seq_along(dist_sum)) {
for(k in seq_along(sig_level)){
TypeI.errorRate_t[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t)
TypeI.errorRate_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_wilcox)
TypeI.errorRate_t_wilcox[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_t_wilcox)
TypeI.errorRate_perm[t, j, k] <- (sim_out[[t]][[j]][[k]]$error_perm)
}
}
}
})
