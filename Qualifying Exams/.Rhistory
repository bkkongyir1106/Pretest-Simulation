## ------------------------------------------------------------
generate_tests <- function(x, test) {
if (test == "KS") {
nortest::lillie.test(x)
} else if (test == "SW") {
shapiro.test(x)
} else if (test == "JB") {
tseries::jarque.bera.test(x)
} else if (test == "DAP") {
moments::agostino.test(x)
} else if (test == "ANS") {
moments::anscombe.test(x)
} else if (test == "AD") {
nortest::ad.test(x)
} else if (test == "AD2") {
DescTools::AndersonDarlingTest(x)
} else if (test == "SF") {
nortest::sf.test(x)
} else if (test == "CVM") {
nortest::cvm.test(x)
} else if (test == "CHISQ") {
breaks   <- pretty(x, n = sqrt(length(x)))
observed <- table(cut(x, breaks = breaks))
expected <- dnorm(breaks[-length(breaks)], mean(x), sd(x))
expected <- expected / sum(expected) * sum(observed)
chisq.test(x = observed, p = expected, rescale.p = TRUE,
simulate.p.value = TRUE)
} else if (test == "SKEW") {
s  <- moments::skewness(x)
se <- sqrt(6 / length(x))
z  <- s / se
p  <- 2 * (1 - pnorm(abs(z)))
list(statistic = z, p.value = p, method = "Skewness z-test")
} else if (test == "KURT") {
k  <- moments::kurtosis(x)
se <- sqrt(24 / length(x))
z  <- (k - 3) / se
p  <- 2 * (1 - pnorm(abs(z)))
list(statistic = z, p.value = p, method = "Kurtosis z-test")
} else {
stop("Unknown test name.")
}
}
## ------------------------------------------------------------
## General normality check wrapper
## ------------------------------------------------------------
normality_test <- function(data, test = "SW", alpha = 0.05) {
pvals <- NULL
all_normality_satisfied <- NULL
## Case 1: single numeric vector
if (is.numeric(data) && is.atomic(data) && is.null(dim(data))) {
pval <- generate_tests(data, test = test)$p.value
pvals <- pval
all_normality_satisfied <- pval > alpha
## Case 2: list of numeric vectors
} else if (is.list(data) && !is.data.frame(data)) {
pvals <- sapply(data, function(sample) {
generate_tests(sample, test = test)$p.value
})
all_normality_satisfied <- all(pvals > alpha)
## Case 3: wide data frame (all numeric columns)
} else if (is.data.frame(data) && all(sapply(data, is.numeric))) {
pvals <- sapply(as.list(data), function(sample)
generate_tests(sample, test = test)$p.value)
all_normality_satisfied <- all(pvals > alpha)
## Case 4: long format, first col = group, second = value
} else if ((is.data.frame(data) || is.matrix(data)) && ncol(data) >= 2) {
grouped_samples <- split(data[[2]], data[[1]])
pvals <- sapply(grouped_samples, function(sample) {
generate_tests(sample, test = test)$p.value
})
all_normality_satisfied <- all(pvals > alpha)
} else {
stop("Unsupported input type for normality_test().")
}
list(p_values = pvals, normality_satisfied = all_normality_satisfied)
}
## ------------------------------------------------------------
## Downstream tests: t-test and Wilcoxon
## ------------------------------------------------------------
fn_for_ds_test_1 <- function(data) {
x_data <- data$value[data$group == "x"]
y_data <- data$value[data$group == "y"]
test_result <- t.test(x = x_data, y = y_data, var.equal = FALSE)
list(p.value = test_result$p.value)
}
fn_for_ds_test_2 <- function(data) {
x_data <- data$value[data$group == "x"]
y_data <- data$value[data$group == "y"]
test_result <- wilcox.test(x_data, y_data)
list(p.value = test_result$p.value)
}
## ------------------------------------------------------------
## Adaptive downstream test (pretest for normality)
## ------------------------------------------------------------
ds_test_function <- function(
gen_data = gen_data,
get_parameters = get_parameters,
fn_to_get_norm_obj = function(d) d,
fn_for_norm_test = normality_test,
fn_for_ds_test_1 = fn_for_ds_test_1,
fn_for_ds_test_2 = fn_for_ds_test_2,
paras = NULL,
alpha = 0.05,
norm_test_method = "SW",
alpha_pre = 0.05,
...
) {
data <- if (!is.null(paras)) do.call(gen_data, paras) else gen_data()
normality_test_object <- fn_to_get_norm_obj(data)
norm_res <- fn_for_norm_test(
data = normality_test_object,
test = norm_test_method,
alpha = alpha_pre
)
if (isTRUE(norm_res$normality_satisfied)) {
ds_test <- fn_for_ds_test_1(data)
} else {
ds_test <- fn_for_ds_test_2(data, ...)
}
ds_test$p.value
}
## ------------------------------------------------------------
## Trapezoidal AUC over sample size (used for AUC-Power, AUC-Type-I)
## ------------------------------------------------------------
compute_area <- function(x, y) {
sum(diff(x) * (head(y, -1) + tail(y, -1)) / 2) / (max(x) - min(x))
}
## ------------------------------------------------------------
## Main simulation over sample sizes (test_1, test_2, adaptive)
## ------------------------------------------------------------
perform_ds_func <- function(
sample_sizes,
distributions = c("exponential", "normal"),
Nsim = 1000,
alpha = 0.05,
norm_test_method = "SW",
effect_size = 0.5,
alpha_pre = 0.05,
...
) {
ds_test_methods <- c("test_1", "test_2", "adaptive")
results_by_dist <- list()
for (dist in distributions) {
cat("\n=== Running simulation for distribution:", dist, "===\n")
results_power <- list()
results_type1 <- list()
timing        <- list()
pval_storage  <- list(H0 = list(), H1 = list())
for (method in ds_test_methods) {
cat("Method:", method, "\n")
pow_vec  <- typ1_vec <- numeric(length(sample_sizes))
names(pow_vec) <- names(typ1_vec) <- paste0("n=", sample_sizes)
pval_storage$H0[[method]] <- vector("list", length(sample_sizes))
pval_storage$H1[[method]] <- vector("list", length(sample_sizes))
pb <- txtProgressBar(min = 0, max = length(sample_sizes), style = 3)
t0 <- Sys.time()
for (i in seq_along(sample_sizes)) {
n <- sample_sizes[i]
rej_H0 <- rej_H1 <- 0L
p_H0   <- p_H1   <- numeric(Nsim)
for (sim in seq_len(Nsim)) {
## parameters under H0 and H1, using the chosen distribution
paras_H0 <- get_parameters(n, effect_size = 0.0, dist = dist)
paras_H1 <- get_parameters(n, effect_size = effect_size, dist = dist)
## generate the two-sample data sets
dat_H0 <- do.call(gen_data, paras_H0)
dat_H1 <- do.call(gen_data, paras_H1)
if (method == "test_1") {
p0 <- fn_for_ds_test_1(dat_H0)$p.value
p1 <- fn_for_ds_test_1(dat_H1)$p.value
} else if (method == "test_2") {
p0 <- fn_for_ds_test_2(dat_H0)$p.value
p1 <- fn_for_ds_test_2(dat_H1)$p.value
} else {  ## adaptive: pretest normality then choose test_1 vs test_2
p0 <- ds_test_function(
gen_data           = gen_data,
get_parameters     = get_parameters,
fn_to_get_norm_obj = function(d) d,
fn_for_norm_test   = normality_test,
fn_for_ds_test_1   = fn_for_ds_test_1,
fn_for_ds_test_2   = fn_for_ds_test_2,
paras              = paras_H0,
alpha              = alpha,
norm_test_method   = norm_test_method,
alpha_pre          = alpha_pre,
...
)
p1 <- ds_test_function(
gen_data           = gen_data,
get_parameters     = get_parameters,
fn_to_get_norm_obj = function(d) d,
fn_for_norm_test   = normality_test,
fn_for_ds_test_1   = fn_for_ds_test_1,
fn_for_ds_test_2   = fn_for_ds_test_2,
paras              = paras_H1,
alpha              = alpha,
norm_test_method   = norm_test_method,
alpha_pre          = alpha_pre,
...
)
}
p_H0[sim] <- p0
p_H1[sim] <- p1
if (p0 < alpha) rej_H0 <- rej_H0 + 1
if (p1 < alpha) rej_H1 <- rej_H1 + 1
}
typ1_vec[i] <- rej_H0 / Nsim
pow_vec[i]  <- rej_H1 / Nsim
pval_storage$H0[[method]][[i]] <- p_H0
pval_storage$H1[[method]][[i]] <- p_H1
setTxtProgressBar(pb, i)
}
close(pb)
timing[[method]]        <- as.numeric(difftime(Sys.time(), t0, units = "secs"))
results_type1[[method]] <- typ1_vec
results_power[[method]] <- pow_vec
cat("Method", method, "completed in", round(timing[[method]], 2), "seconds\n")
}
results_by_dist[[dist]] <- list(
power   = results_power,
type1   = results_type1,
pvalues = pval_storage,
timing  = timing
)
}
results_by_dist
}
## ------------------------------------------------------------
## Plot power and type-I error vs sample size
## ------------------------------------------------------------
plot_power_type1 <- function(
combined_power,
combined_type1,
methods = c("test_1", "test_2", "adaptive"),
distributions = NULL,
sizes,
alpha,
filename = NULL,
width = 7,
height = 6
) {
colors <- c("red", "blue", "green")
shapes <- c(19, 17, 15)
if (!is.null(filename)) {
pdf(filename, width = width, height = height)
on.exit(dev.off())
}
if (is.null(distributions)) {
distributions <- unique(combined_power$Distribution)
}
layout(matrix(c(1,2,3,4,5,5), nrow = 3, byrow = TRUE),
heights = c(1, 1, 0.25))
op <- par(mar = c(2.6, 3.2, 1.2, 0.8),
oma = c(0, 0, 1.6, 0),
mgp = c(1.6, 0.45, 0),
tcl = -0.2,
cex.axis = 0.75,
cex.lab  = 0.75)
on.exit(par(op), add = TRUE)
create_plot <- function(data, ylab, main, hline = NULL) {
xlim <- range(sizes) + c(-1, 1) * 0.02 * diff(range(sizes))
plot(NA, xlim = xlim, ylim = c(0, 1.01),
xlab = "Sample Size", ylab = ylab, main = main)
for (i in seq_along(methods)) {
lines(data$n, data[[methods[i]]],
type = "b", col = colors[i], pch = shapes[i], lwd = 2)
}
if (!is.null(hline))
abline(h = hline, col = "gray50", lty = 2)
}
for (dist in distributions) {
data_power <- subset(combined_power, Distribution == dist)
create_plot(data_power, "Power", paste("Power -", dist), 0.75)
}
for (dist in distributions) {
data_type1 <- subset(combined_type1, Distribution == dist)
ymax <- max(data_type1[methods], na.rm = TRUE)
plot(NA, xlim = range(sizes), ylim = c(0, ymax * 1.02),
xlab = "Sample Size", ylab = "P(Type I Error)",
main = paste("P(Type I Error) -", dist))
for (i in seq_along(methods)) {
lines(data_type1$n, data_type1[[methods[i]]],
type = "b", col = colors[i], pch = shapes[i], lwd = 2)
}
abline(h = alpha, col = "gray50", lty = 3)
}
par(mar = c(0.2, 0.2, 0.2, 0.2))
plot.new()
legend("center", legend = methods, col = colors, pch = shapes,
lwd = 2, horiz = TRUE, bty = "n", cex = 0.75, title = "Methods")
}
## =============================== ##
##      PART (A) MAIN SCRIPT       ##
## =============================== ##
## load libraries
library(nortest)
library(tseries)
library(moments)
library(DescTools)
set.seed(123)
distributions <- c("exponential", "normal")
sample_sizes  <- c(10, 20, 30, 40, 50)
effect_size   <- 0.5
alpha_ds      <- 0.05
alpha_pre     <- 0.05
Nsim          <- 1e5
## 1. Run simulations to estimate power & type-I error vs n
sim_results <- perform_ds_func(
sample_sizes  = sample_sizes,
distributions = distributions,
Nsim          = Nsim,
alpha         = alpha_ds,
effect_size   = effect_size,
alpha_pre     = alpha_pre
)
## 2. Compute AUC-Power and AUC-Type-I-Error for each method
auc_tables <- list()
for (dist in names(sim_results)) {
cat("\n\n=== Results for", dist, "distribution ===\n")
dist_results  <- sim_results[[dist]]
power_results <- dist_results$power
type1_results <- dist_results$type1
auc_power <- sapply(power_results,
function(y) compute_area(sample_sizes, y))
auc_type1 <- sapply(type1_results,
function(y) compute_area(sample_sizes, y))
tab <- data.frame(
Method    = names(auc_power),
AUC_Power = as.numeric(auc_power),
AUC_TypeI = as.numeric(auc_type1),
row.names = NULL
)
auc_tables[[dist]] <- tab
print(tab, digits = 4)
}
## 3. Build combined data frames for plotting
all_power <- list()
all_type1 <- list()
for (dist in names(sim_results)) {
dist_res <- sim_results[[dist]]
all_power[[dist]] <- data.frame(
n            = sample_sizes,
test_1       = dist_res$power$test_1,
test_2       = dist_res$power$test_2,
adaptive     = dist_res$power$adaptive,
Distribution = dist
)
all_type1[[dist]] <- data.frame(
n            = sample_sizes,
test_1       = dist_res$type1$test_1,
test_2       = dist_res$type1$test_2,
adaptive     = dist_res$type1$adaptive,
Distribution = dist
)
}
combined_power <- do.call(rbind, all_power)
combined_type1 <- do.call(rbind, all_type1)
## 4. Plot Part (A): power and type I vs sample size
pdf("part_a_power_type1.pdf", width = 7, height = 6)
plot_power_type1(
combined_power = combined_power,
combined_type1 = combined_type1,
distributions  = distributions,
sizes          = sample_sizes,
alpha          = alpha_ds
)
dev.off()
## =============================== ##
##      PART (B) â€“ F-HAT EFFECT    ##
## =============================== ##
## Helper: adaptive p-value for a given data set
adaptive_pvalue <- function(data, alpha_pre, norm_test_method = "SW") {
norm_res <- normality_test(
data = data,
test = norm_test_method,
alpha = alpha_pre
)
if (isTRUE(norm_res$normality_satisfied)) {
fn_for_ds_test_1(data)$p.value  # t-test
} else {
fn_for_ds_test_2(data)$p.value  # Wilcoxon
}
}
## Given one pilot sample, estimate AUC-Power and AUC-Type-I
## by resampling from that pilot (simulating from F-hat)
simulate_auc_from_pilot <- function(pilot_sample,
sample_sizes,
Nsim_inner,
effect_size,
alpha_ds,
alpha_pre,
norm_test_method = "SW") {
methods <- c("test_1", "test_2", "adaptive")
power_list <- vector("list", length(methods))
type1_list <- vector("list", length(methods))
names(power_list) <- names(type1_list) <- methods
for (m in seq_along(methods)) {
method  <- methods[m]
pow_vec <- numeric(length(sample_sizes))
typ1_vec <- numeric(length(sample_sizes))
for (j in seq_along(sample_sizes)) {
n <- sample_sizes[j]
rej_H0 <- rej_H1 <- 0L
for (sim in seq_len(Nsim_inner)) {
## H0: both groups from F-hat
z1_H0 <- sample(pilot_sample, n, replace = TRUE)
z2_H0 <- sample(pilot_sample, n, replace = TRUE)
data_H0 <- data.frame(
group = factor(rep(c("x", "y"), each = n)),
value = c(z1_H0, z2_H0)
)
## H1: same F-hat but group y shifted by effect_size
z1_H1 <- sample(pilot_sample, n, replace = TRUE)
z2_H1 <- sample(pilot_sample, n, replace = TRUE)
data_H1 <- data.frame(
group = factor(rep(c("x", "y"), each = n)),
value = c(z1_H1, z2_H1 + effect_size)
)
if (method == "test_1") {
p0 <- fn_for_ds_test_1(data_H0)$p.value
p1 <- fn_for_ds_test_1(data_H1)$p.value
} else if (method == "test_2") {
p0 <- fn_for_ds_test_2(data_H0)$p.value
p1 <- fn_for_ds_test_2(data_H1)$p.value
} else { # adaptive
p0 <- adaptive_pvalue(data_H0,
alpha_pre = alpha_pre,
norm_test_method = norm_test_method)
p1 <- adaptive_pvalue(data_H1,
alpha_pre = alpha_pre,
norm_test_method = norm_test_method)
}
if (p0 < alpha_ds) rej_H0 <- rej_H0 + 1L
if (p1 < alpha_ds) rej_H1 <- rej_H1 + 1L
}
typ1_vec[j] <- rej_H0 / Nsim_inner
pow_vec[j]  <- rej_H1 / Nsim_inner
}
power_list[[method]] <- pow_vec
type1_list[[method]] <- typ1_vec
}
## Convert curves into AUCs (same definition as in Part A)
auc_power <- sapply(power_list,
function(y) compute_area(sample_sizes, y))
auc_type1 <- sapply(type1_list,
function(y) compute_area(sample_sizes, y))
data.frame(
Method    = names(auc_power),
AUC_Power = as.numeric(auc_power),
AUC_TypeI = as.numeric(auc_type1),
row.names = NULL
)
}
## Choose the non-normal F' used in Part (A)
non_normal_dist <- "exponential"
## "True" AUCs from Part (A) for this F'
true_auc <- auc_tables[[non_normal_dist]]
true_auc <- true_auc[match(c("test_1", "test_2", "adaptive"),
true_auc$Method), ]
true_auc
## Part (B) tuning parameters
M       <- 100    # number of pilot samples
n_pilot <- 200    # pilot sample size
N_inner <- 1000   # inner Monte Carlo reps per pilot
pilot_auc_list <- vector("list", M)
for (m in seq_len(M)) {
cat("Pilot replicate", m, "of", M, "\n")
## Pilot sample from the true F' (exponential here)
pilot_sample <- generate_data(n_pilot, dist = non_normal_dist)
## AUC estimates using this F-hat
pilot_auc_list[[m]] <- simulate_auc_from_pilot(
pilot_sample    = pilot_sample,
sample_sizes    = sample_sizes,
Nsim_inner      = N_inner,
effect_size     = effect_size,
alpha_ds        = alpha_ds,
alpha_pre       = alpha_pre,
norm_test_method = "SW"
)
}
## Stack all M runs into one data frame
pilot_auc_df <- do.call(rbind, lapply(seq_len(M), function(m) {
cbind(Replicate = m, pilot_auc_list[[m]])
}))
## Boxplots comparing AUC estimates (from F-hat) with true AUCs
pdf("part_b_auc_boxplots.pdf", width = 8, height = 4.5)
par(mfrow = c(1, 2),
mar = c(4, 4, 3, 1),
oma = c(0, 0, 2, 0))
## Panel 1: AUC-Power
boxplot(AUC_Power ~ Method, data = pilot_auc_df,
ylab = "AUC-Power",
main = "AUC-Power estimates\n(from empirical F-hat)")
points(1:3, true_auc$AUC_Power, pch = 19, col = "red")
text(1:3, true_auc$AUC_Power,
labels = sprintf("%.3f", true_auc$AUC_Power),
pos = 3, cex = 0.7, col = "red")
## Panel 2: AUC-Type-I
boxplot(AUC_TypeI ~ Method, data = pilot_auc_df,
ylab = "AUC-Type-I Error",
main = "AUC-Type-I estimates\n(from empirical F-hat)")
points(1:3, true_auc$AUC_TypeI, pch = 19, col = "red")
text(1:3, true_auc$AUC_TypeI,
labels = sprintf("%.3f", true_auc$AUC_TypeI),
pos = 3, cex = 0.7, col = "red")
mtext(sprintf("Part (b): F' = %s, pilot n = %d, N_inner = %d, M = %d",
non_normal_dist, n_pilot, N_inner, M),
outer = TRUE, side = 3, line = 0.2, cex = 0.9)
dev.off()
pilot_auc_df
true_auc
