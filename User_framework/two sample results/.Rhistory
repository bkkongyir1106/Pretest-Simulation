}
list(power = results_power, type1 = results_type1, pvalues = pval_storage, timing = timing)
}
# -------------------------------------------------------
# ------- Main simulation: power/Type I error analysis --
# ---- Main simulation
Nsim        <- 1e5
sizes       <- c(10, 20, 30, 40, 50)
alpha       <- 0.05
norm_test   <- "SW"
effect_size <- 0.5
ds_test_methods <- c("parametric", "nonparametric", "adaptive")
sim_output <- perform_ds_func(
sample_sizes       = sizes,
Nsim               = Nsim,
alpha              = alpha,
gen_data           = gen_data,
get_parameters     = get_parameters,
fn_to_get_norm_obj = fn_to_get_norm_obj,
fn_for_norm_test   = normality_test,
fn_for_ds_test_1   = fn_for_ds_test_1,
fn_for_ds_test_2   = fn_for_ds_test_2,
norm_test_method   = norm_test,
ds_test_methods    = ds_test_methods,
effect_size        = effect_size
)
power_results <- sim_output$power
type1_results <- sim_output$type1
timing_results <- sim_output$timing
pvals_all <- sim_output$pvalues
# Convenience aliases
pow_t     <- power_results$parametric
pow_w     <- power_results$nonparametric
pow_adapt <- power_results$adaptive
err_t     <- type1_results$parametric
err_w     <- type1_results$nonparametric
err_adapt <- type1_results$adaptive
# Optional AUC for power curves
compute_area <- function(sample_sizes, y) {
if (is.null(y) || length(y) != length(sample_sizes)) return(NA_real_)
sum(diff(sample_sizes) * (head(y, -1) + tail(y, -1)) / 2) /
(max(sample_sizes) - min(sample_sizes))
}
# Curves (from your previous run)
pow_curves <- list(
Parametric    = power_results$parametric,
Nonparametric = power_results$nonparametric,
Adaptive      = power_results$adaptive
)
err_curves <- list(
Parametric    = type1_results$parametric,
Nonparametric = type1_results$nonparametric,
Adaptive      = type1_results$adaptive
)
# AUCs
auc_power <- sapply(pow_curves, function(y) compute_area(sizes, y))
auc_type1 <- sapply(err_curves, function(y) compute_area(sizes, y))
auc_table <- data.frame(
Method    = names(auc_power),
AUC_Power = unname(auc_power),
AUC_TypeI = unname(auc_type1),
row.names = NULL
)
print(auc_table, digits = 4)
# ------------------------------------------------------------------------------
# ----------------- Plot Power/Type I error -----------------------
pdf("two_sample_test_power_and_typeI.pdf", width = 12, height = 6)
op <- par(no.readonly = TRUE); on.exit(try(par(op), silent = TRUE), add = TRUE)
par(mfrow = c(1, 2), mar = c(4.2, 4.5, 3, 1))
# Power panel (left)
plot(sizes, pow_curves$Parametric, type="b", pch=19, col="red", lwd=2,
ylim=c(0,1), xlab="Sample Size (per group)", ylab="Power",
main="Power vs Sample Size(Exp)")
lines(sizes, pow_curves$Nonparametric, type="b", pch=17, col="blue",  lwd=2)
lines(sizes, pow_curves$Adaptive,      type="b", pch=15, col="green", lwd=2)
abline(h = 0.8, col = "gray50", lty = 2, lwd = 1.5)
legend("bottomright",
legend = paste0(c("Parametric","Nonparametric","Adaptive"),
" (AUC=", formatC(auc_power[c("Parametric","Nonparametric","Adaptive")],
format="f", digits=3), ")"),
col = c("red","blue","green"), pch = c(19,17,15), lty = 1, lwd = 2, bty = "b")
# Type I error panel (right)
plot(sizes, err_curves$Parametric, type="b", pch=19, col="red", lwd=2,
ylim=c(0, max(0.12, err_curves$Parametric, err_curves$Nonparametric, err_curves$Adaptive, na.rm=TRUE)),
xlab="Sample Size (per group)", ylab="Type I Error",
main="Type I Error vs Sample Size(Exp)")
lines(sizes, err_curves$Nonparametric, type="b", pch=17, col="blue",  lwd=2)
lines(sizes, err_curves$Adaptive,      type="b", pch=15, col="green", lwd=2)
abline(h = alpha, col = "gray40", lty = 3, lwd = 1.5)
legend("topleft",
legend = paste0(c("Parametric","Nonparametric","Adaptive"),
" (AUC=", formatC(auc_type1[c("Parametric","Nonparametric","Adaptive")],
format="f", digits=3), ")"),
col = c("red","blue","green"), pch = c(19,17,15), lty = 1, lwd = 2, bty = "b")
dev.off()
# =============================================================================
# -----------------------------------------------------------------------------
# Function to compute FPR and TPR for Normality Test Methods
# -----------------------------------------------------------------------------
fn_for_roc_curve_for_norm_test <- function(n, alpha_pretest, H1_dist, tests, Nsim = 1e3) {
FPR <- TPR <- matrix(0, nrow = length(tests), ncol = length(alpha_pretest))
rownames(FPR) <- rownames(TPR) <- tests
colnames(FPR) <- colnames(TPR) <- paste0("alpha_", alpha_pretest)
pb <- txtProgressBar(min = 0, max = Nsim * length(tests) * length(alpha_pretest), style = 3)
counter <- 0
for (i in seq_along(tests)) {
test_name <- tests[i]
for (j in seq_along(alpha_pretest)) {
alpha <- alpha_pretest[j]
reject_H0 <- reject_H1 <- numeric(Nsim)
for (k in 1:Nsim) {
# Under H0
paras_H0 <- get_parameters(n, dist = "Normal", par = NULL)
normal_data <- do.call(gen_data, paras_H0)
# Under H1
paras_H1 <- get_parameters(n, dist = H1_dist)
non_normal_data <- do.call(gen_data, paras_H1)
# Get normality test object
normal_data <- fn_to_get_norm_obj(normal_data)
non_normal_data <- fn_to_get_norm_obj(non_normal_data)
# perform normality test for H0 and H1
pvals_H0 <- normality_test(normal_data, test = test_name, alpha = alpha)$p_values
reject_H0[k] <- any(pvals_H0 < alpha, na.rm = TRUE)
pvals_H1 <- normality_test(non_normal_data, test = test_name, alpha = alpha)$p_values
reject_H1[k] <- any(pvals_H1 < alpha, na.rm = TRUE)
counter <- counter + 1
setTxtProgressBar(pb, counter)
}
# calculate FPR & TPR
FPR[i, j] <- mean(reject_H0, na.rm = TRUE)
TPR[i, j] <- mean(reject_H1, na.rm = TRUE)
}
}
close(pb)
return(list(
pvals_H0 = pvals_H0,
pvals_H1 = pvals_H1,
FPR = FPR,
TPR = TPR,
alpha = alpha_pretest))
}
# --------------- Run the simulation -------------------
Nsim = 1e5
alpha_pretest = seq(from = 0.0, to = 1, by = 0.05)
roc_pval_ds_test <- fn_for_roc_curve_for_norm_test(
n = 10,
alpha_pretest = alpha_pretest,
H1_dist = "exponential",
tests = c("SW", "SF", "JB","SKEW", "DAP", "AD", "CVM"),
Nsim = Nsim
)
# ------------------------------------------------------------------------------
#              Function to plot ROC curves from FPR and TPR matrices
# ------------------------------------------------------------------------------
roc_curve_for_norm_test <- function(FPR, TPR, tests_to_plot = rownames(FPR), alpha = NULL,
title = "ROC Curves for Different Normality Tests(Chisq_3)") {
# define line colors and plot characters
colors <- 1:length(tests_to_plot)
#colors <- rainbow(length(tests_to_plot))
plot_chars <- 1:length(tests_to_plot) + 14
# create an empty plot
plot(0, 0, type = "n",
xlim = c(0, 1),
ylim = c(0, 1),
xlab = "False Positive Rate (FPR)",
ylab = "True Positive Rate (TPR)",
main = title)
# add lines for each test
for (i in seq_along(tests_to_plot)) {
test <- tests_to_plot[i]
lines(FPR[test, ], TPR[test, ], col = colors[i], lwd = 2)
points(FPR[test, ], TPR[test, ], col = colors[i], pch = plot_chars[i], cex = 0.5)
}
# add reference line
abline(0, 1, lty = 2, col = "gray")
legend("bottomright",
legend = tests_to_plot,
col = colors,
pch = plot_chars,
lwd = 2,
title = "Normality Tests")
}
# Plot ROC using selected tests
pdf("two_sample_test_norm_roc_curve.pdf", width=12, height=8)
selected_tests <- c("SW", "SF", "JB","SKEW", "DAP", "AD")
roc_curve_for_norm_test(FPR = roc_pval_ds_test$FPR,
TPR = roc_pval_ds_test$TPR,
tests_to_plot = selected_tests,
alpha = roc_pval_ds_test$alpha)
dev.off()
# =============================================================================
# -----------------------------------------------------------------------------
# Function to compute p-values for normality test & downstream tests
# -----------------------------------------------------------------------------
generate_pval<- function(N, n, effect_size, test = "SW", dist = "Normal", ...) {
# Initialize storage
pval_t.test_H0 <- pval_wilcox.test_H0 <- numeric(N)
pval_t.test_H1 <- pval_wilcox.test_H1 <- numeric(N)
norm_pvals_H0 <- norm_pvals_H1 <- vector("list", N)
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in 1:N) {
# Under null hypothesis
paras_H0 <- get_parameters(n, dist = dist, effect_size = 0)
data_H0 <- do.call(gen_data, paras_H0)
# Under alternative hypothesis
paras_H1 <- get_parameters(n, dist = dist, effect_size = effect_size)
data_H1 <- do.call(gen_data, paras_H1)
# Get normality test objects
normality_test_object_H0 <- fn_to_get_norm_obj(data_H0)
normality_test_object_H1 <- fn_to_get_norm_obj(data_H1)
# perform normality test
normality_test_H0 <- normality_test(normality_test_object_H0, test = test, alpha = 0.05)
normality_test_H1 <- normality_test(normality_test_object_H1, test = test, alpha = 0.05)
# Store normality p-values
norm_pvals_H0[[i]] <- normality_test_H0$p_values
norm_pvals_H1[[i]] <- normality_test_H1$p_values
# Get test p-values under null and alternative
pval_t.test_H0[i] <- fn_for_ds_test_1(data_H0)$p.value
pval_wilcox.test_H0[i] <- fn_for_ds_test_2(data_H0)$p.value
pval_t.test_H1[i] <- fn_for_ds_test_1(data_H1)$p.value
pval_wilcox.test_H1[i] <- fn_for_ds_test_2(data_H1)$p.value
setTxtProgressBar(pb, i)
}
close(pb)
return(list(
pval_t.test_H0 = pval_t.test_H0,
pval_wilcox.test_H0 = pval_wilcox.test_H0,
pval_t.test_H1 = pval_t.test_H1,
pval_wilcox.test_H1 = pval_wilcox.test_H1,
norm_pvals_H0 = norm_pvals_H0,
norm_pvals_H1 = norm_pvals_H1
))
}
# --------------- Calculate power/Type I errors for each test method --------------
perform_analysis <- function(N, n, distributions, effect_size, test, alpha_pretest, test_alpha) {
ds_test_results <- list()
error_ds_test <- list()
power_ds_test <- list()
pb_dist <- txtProgressBar(min = 0, max = length(distributions), style = 3)
for(dist_idx in seq_along(distributions)) {
dist <- distributions[dist_idx]
cat("Processing distribution:", dist, "\n")
# Store all p-values from generate_pval
ds_test_results[[dist]] <- generate_pval(N, n, effect_size = effect_size, test = "SW" , dist = dist)
# Calculate Type I error rates (under H0)
error_ds_test[[dist]] <- list(
error_t.test = mean(ds_test_results[[dist]]$pval_t.test_H0 < test_alpha),
error_wilcox.test = mean(ds_test_results[[dist]]$pval_wilcox.test_H0 < test_alpha),
# storage for adaptive test for error
adaptive_wilcox_error = numeric(length(alpha_pretest)))
# Calculate Power (under H1)
power_ds_test[[dist]] <- list(
power_t.test = mean(ds_test_results[[dist]]$pval_t.test_H1 < test_alpha),
power_wilcox.test = mean(ds_test_results[[dist]]$pval_wilcox.test_H1 < test_alpha),
# storage for adaptive test for power
adaptive_wilcox_power = numeric(length(alpha_pretest)))
pb_alpha <- txtProgressBar(min = 0, max = length(alpha_pretest), style = 3)
# compute decisions for each alpha level
for(j in seq_along(alpha_pretest)) {
alpha <- alpha_pretest[j]
# For Type I error (H0)
use_t_test_H0 <- sapply(ds_test_results[[dist]]$norm_pvals_H0, function(x) all(x > alpha))
adaptive_pvals_H0 <- ifelse(use_t_test_H0,
ds_test_results[[dist]]$pval_t.test_H0,
ds_test_results[[dist]]$pval_wilcox.test_H0)
error_ds_test[[dist]]$adaptive_wilcox_error[j] <- mean(adaptive_pvals_H0 < test_alpha)
# For Power (H1)
use_t_test_H1 <- sapply(ds_test_results[[dist]]$norm_pvals_H1, function(x) all(x > alpha))
adaptive_pvals_H1 <- ifelse(use_t_test_H1,
ds_test_results[[dist]]$pval_t.test_H1,
ds_test_results[[dist]]$pval_wilcox.test_H1)
power_ds_test[[dist]]$adaptive_wilcox_power[j] <- mean(adaptive_pvals_H1 < test_alpha)
setTxtProgressBar(pb_alpha, j)
}
close(pb_alpha)
setTxtProgressBar(pb_dist, dist_idx)
}
close(pb_dist)
return(list(
error_ds_test = error_ds_test,
power_ds_test = power_ds_test,
all_pvalues     = ds_test_results   # raw p-values saved here
))
}
# run analysis to get power and error
Nsim <- 1e6
alpha_pretest = seq(from = 0.005, to = 1, by = 0.005)
#alpha_pretest = seq(from = 0.009, to = 1, by = 0.0025)
analysis_ds_tests <- perform_analysis(
N = Nsim,
n = 10,
distributions = c("Normal", "lognormal"),
effect_size = effect_size,
test = "SW",
alpha_pretest = alpha_pretest,
test_alpha = 0.05
)
# ------------------------------------------------------------------------------
#                         Function to compute ROC-like metrics
# ------------------------------------------------------------------------------
compute_roc_metrics <- function(error_ds_test, power_ds_test, test_alpha) {
# Non-normal case
power_t_test_nonnormal <- power_ds_test[[ 2 ]]$power_t.test
adaptive_power_nonnormal <- power_ds_test[[ 2 ]]$adaptive_wilcox_power
adaptive_error_nonnormal <- error_ds_test[[ 2 ]]$adaptive_wilcox_error
EPG <- (adaptive_power_nonnormal - power_t_test_nonnormal)
EDE <- (adaptive_error_nonnormal - test_alpha)
# normal case
power_t_test_normal <- power_ds_test[[ 1 ]]$power_t.test
adaptive_power_normal <- power_ds_test[[ 1 ]]$adaptive_wilcox_power
adaptive_error_normal <- error_ds_test[[ 1 ]]$adaptive_wilcox_error
EPL <- power_t_test_normal - adaptive_power_normal
EIE <- (adaptive_error_normal - test_alpha)
# Point estimates for benchmark comparison
power_gain <- power_ds_test[[ 2 ]]$power_wilcox.test - power_ds_test[[ 2 ]]$power_t.test
power_loss <- power_ds_test[[ 1 ]]$power_t.test - power_ds_test[[ 1 ]]$power_wilcox.test
return(list(EPL = EPL,
EPG = EPG,
EIE = EIE,
EDE = EDE,
power_gain = power_gain,
power_loss = power_loss)
)
}
# Compute metrics after running analysis
metrics <- compute_roc_metrics(
error_ds_test = analysis_ds_tests$error_ds_test,
power_ds_test = analysis_ds_tests$power_ds_test,
test_alpha    = 0.05
)
# --------------------------------------------------------------------
# Power and Type I error trade-off plots
plot_power_error_tradeoff <- function(alpha_pretest, metrics, file_name = NULL) {
# if (!is.null(file_name)) pdf(file_name, width = 12, height = 10)
par(mfrow = c(2, 2))
plot(alpha_pretest,
metrics$EPL,
type = "l",
col = "blue",
lwd = 2,
ylab = "Expected Power Loss (EPL)",
xlab = expression(alpha),
main = "Expected Power Loss(Normal)")
plot(alpha_pretest,
metrics$EPG,
type = "l",
col = "red",
lwd = 2,
ylab = "Expected Power Gain (EPG)",
xlab = expression(alpha),
main = "Expected Power Gain(Non-Normal)")
plot(alpha_pretest,
metrics$EIE,
type = "l",
col = "orange",
lwd = 2,
ylab = "Inflation of Type I Error",
xlab = expression(alpha),
main = "EI/D of Type I error (Normal)")
plot(alpha_pretest,
metrics$EDE,
type = "l",
col = "green",
lwd = 2,
ylab = "Inflation of Type I Error",
xlab = expression(alpha),
main = "EI/D of Type I error (Non-Normal)")
if (!is.null(file_name)) dev.off()
}
# Generate all plots
pdf("two_sample_test_tradeoff_v2.pdf", width=12, height=8)
plot_power_error_tradeoff(
alpha_pretest = alpha_pretest,
metrics = metrics
#file_name = "comparison_power_error.pdf"
)
dev.off()
EPL_vs_EPG_ROC_like_curve <- function(metrics){
par(mfrow = c(1, 2))
plot(metrics$EPL,
metrics$EPG,
type = "l",
col = "blue",
lwd = 2,
ylab = "EPL(Non-normal)",
xlab = "EPL(Normal)",
main = "ROC like curve: Expected Power Loss/Gain")
plot(sort(metrics$EDE),
sort(metrics$EIE),
type = "l",
col = "blue",
lwd = 2,
ylab = "EIE(Normal)",
xlab = "EDE(Non-Normal)",
main = "ROC like curve: Expected I/D of Type I error")
}
pdf("two_sample_test_EPL_vs_EPG_v2.pdf", width=12, height=8)
EPL_vs_EPG_ROC_like_curve(metrics)
dev.off()
# --------------------------------------------------------------------
# ----------- Function to ROC curve data for downstream test ---------
generate_roc_tables <- function(N, n, distributions, effect_size, sig_levels) {
# data frames for Type I error and Power
roc_data <- data.frame()
pb <- txtProgressBar(min = 0, max = length(distributions) * length(sig_levels), style = 3)
counter <- 0
# fixed pretest alpha
alpha_pretest <- 0.05
for (dist in distributions) {
cat("Generating ROC data for:", dist, "\n")
res <- generate_pval(N, n,  effect_size, test = "SW", dist = dist)
# Convert norm_pvals_H0 from list to numeric vector
#norm_pvals_H0_vec <- sapply(res$norm_pvals_H0, function(x) if(is.null(x)) NA else x)
for (alpha in sig_levels) {
# Compute Type I error (under H0)
error_t <- mean(res$pval_t.test_H0 <= alpha)
error_w <- mean(res$pval_wilcox.test_H0 <= alpha)
# For adaptive test
# H0 gate (Type I error)
use_t_test_H0 <- sapply(res$norm_pvals_H0, function(v) all(as.numeric(v) > alpha_pretest))
adaptive_pvals_H0 <- ifelse(use_t_test_H0, res$pval_t.test_H0, res$pval_wilcox.test_H0)
# adaptive_pvals_H0 <- ifelse(use_t_test,
#                             res$pval_t.test_H0,
#                             res$pval_wilcox.test_H0)
error_adaptive <- mean(adaptive_pvals_H0 <= alpha)
# Compute Power (under H1)
power_t <- mean(res$pval_t.test_H1 <= alpha)
power_w <- mean(res$pval_wilcox.test_H1 <= alpha)
# H1 gate (Power) â€” MUST be based on H1 data
use_t_test_H1 <- sapply(res$norm_pvals_H1, function(v) all(as.numeric(v) > alpha_pretest))
adaptive_pvals_H1 <- ifelse(use_t_test_H1, res$pval_t.test_H1, res$pval_wilcox.test_H1)
# adaptive_pvals_H1 <- ifelse(use_t_test,
#                             res$pval_t.test_H1,
#                             res$pval_wilcox.test_H1)
power_adaptive <- mean(adaptive_pvals_H1 <= alpha)
# Append results
roc_data <- rbind(roc_data,
data.frame(
Distribution = dist,
Method = "test 1(t_test)",
Alpha = alpha,
Power = power_t,
TypeIError = error_t
),
data.frame(
Distribution = dist,
Method = "test 2(Wilcoxon)",
Alpha = alpha,
Power = power_w,
TypeIError = error_w
)
,
data.frame(
Distribution = dist,
Method = "adaptive test",
Alpha = alpha,
Power = power_adaptive,
TypeIError = error_adaptive
))
counter <- counter + 1
setTxtProgressBar(pb, counter)
}
}
close(pb)
return(roc_data)
# return(list(roc_data = roc_data,
#            results = res,
#            adaptive_pvals_H0 = adaptive_pvals_H0,
#            adaptive_pvals_H1 = adaptive_pvals_H1))
}
# Example usage:
Nsim <- 1e6
roc_data <- generate_roc_tables(
N = Nsim,
n = 10,
distributions = c("normal", "lognormal"),
effect_size = effect_size,
#sig_levels = seq(from = 0.001, to = 1, by = 0.005)
sig_levels = seq(from = 0.005, to = 1, by = 0.005)
)
# --------------------- create the plots -------------------------------------
plot_power_vs_error_ROC_curve <- function(roc_data, file_name = NULL) {
#if (!is.null(file_name)) pdf(file_name, width = 12, height = 10)
par(mfrow = c(1, length(unique(roc_data$Distribution))))
methods <- unique(roc_data$Method)
colors  <- c("blue", "red", "green")
pch_vals <- c(19, 17, 18)
for (dist in unique(roc_data$Distribution)) {
plot(NA, xlim = c(0, 1),
ylim = c(0, 1),
xlab = "Type I Error",
ylab = "Power",
main = paste("ROC-like Curve (", dist, ")", sep = ""))
for (m in seq_along(methods)) {
method <- methods[m]
data_subset <- subset(roc_data, Distribution == dist & Method == method)
if (nrow(data_subset) > 0) {
lines(data_subset$TypeIError, data_subset$Power, type = "l", col = colors[m], lwd = 2, pch = pch_vals[m])
}
}
legend("bottomright", legend = methods, col = colors,
lwd = 2, pch = pch_vals, title = "Method")
}
}
pdf("two_sample_test_power_error.pdf", width=12, height=6)
plot_power_vs_error_ROC_curve(
roc_data = roc_data
#file_name = "Power_vs_TypeIError_ROC_By_Distribution.pdf"
)
dev.off()
# Save workspace with timestamp
save.image(paste0("two_sample_test_results_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".RData"))
